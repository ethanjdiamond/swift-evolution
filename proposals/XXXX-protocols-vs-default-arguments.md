# Allow methods with default arguments to fulfill protocol requirements

* Proposal: [SE-NNNN](NNNN-filename.md)
* Authors: [Ethan Diamond](https://github.com/ethanjdiamond)
* Review Manager: TBD
* Status: **Awaiting implementation**

## Introduction

Currently, protocols don't take into account default arguments with evaluating whether an implementation fulfills their requirements. This proposal is for protocols to use the callsite to determine if a method fulfills it's requirements instead of the method definition.

[Swift-evolution thread](https://forums.swift.org/t/pitch-allow-functions-with-default-arguments-to-fulfill-protocols/9186)

## Motivation

As a demonstration of the issue in action, assume I have this code:

```
protocol A {
  static func callMe()
}

class B: A {
  static func callMe() { }
}

class C: A {
  static func callMe(param: String = "Hello World") { }
}
```

B will compile properly, while C will display a "class C does not fulfill protocol requirements" error. This is true despite both of these being valid:

```
B.callMe()

C.callMe()
```

There are ways to deal with this issue, but they involve adding extra methods which defeats the purpose of default values in the first place. For example, you can use two methods like this to fulfill the protocol and achieve the same effect:

```
class C: A {
  static func callMe() {
    callMe(param: "Hello World")
  }
  
  static func callMe(param: String) { }
}
```

A bigger issue also comes into play when the default values contain information about the caller:

```
// Desired outcome
class C: A {
   static func callMe(file: String = #file, line: Int = #line) { }
}

// This will have file and line information from C instead of the file that called C
class C: A {
  static func callMe() {
    callMe(file: #file, line: #line)
  }
  
  static func callMe(file: String, line: Int) { }
}
```

## Proposed solution

The proposed solution is for protocols to take the implied methods generated by default values into account when evaluating whether they are fulfulled. For example, this method is actually three implied methods:

```
class C: A {
  static func callMe(file: String = #file, line: Int = #line) { }
}

C.callMe()
C.callMe(file: String)
C.callMe(file: String, line: Int)
```

Therefore, C should fulfill any of these three protocols:

```
protocol A {
  static func callMe()
}

protocol A {
  static func callMe(file: String)
}

protocol A {
  static func callMe(file: String, line: Int)
}
```

## Source compatibility

This will not break any existing protocol/object relationships, and is therefore fully source compatible.

## Effect on ABI stability

This should not effect ABI stability.

## Effect on API resilience

This should not effect API resilience.

## Alternatives considered

The main alternative considered was to allow protocols to require defaults on parameters. For example:

```
protocol A {
  static func callMe(file: String = #default, line: Int = #default)
}

class C: A {
  static func callMe(file: String = #file, line: Int = #line)
}
```

This had the advantage that it would easily allow outside classes who viewed the protocol to know of the three possible implied methods of `callMe()`, `callMe(file: String)` and `callMe(file: String, line: Int)` with one line in the protocol.

On the other hand, it felt strange forcing a class to implement defaults for it's parameter values. There might be cases where a certain implementation might not have sensible defaults to use. In addition, if the method wanted to implement a fourth parameter with a default value it would break the protocol even though it should be a valid option.
